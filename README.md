# Создание системы интернет-магазина

## 1. Описание задачи
### Цель работы
Целью данной работы является разработка консольного приложения для управления интернет-магазином. Проект демонстрирует применение принципов объектно-ориентированного программирования (ООП), современных возможностей языка C++, работу с реляционной базой данных PostgreSQL и интеграцию с библиотекой libpqxx
### Краткое описание реализованной системы интернет-магазина
Реализованная система представляет собой консольное приложение с многопользовательским доступом, поддерживающее три основные роли: Администратор, Менеджер и Покупатель. Система позволяет пользователям просматривать каталог товаров, совершать покупки, управлять заказами, отслеживать историю статусов заказов и вести аудит действий. Администраторы имеют полный контроль над системой, включая управление пользователями и правами доступа.
### Используемые технологии
Язык программирования: C++ (современный стандарт, с использованием STL и умных указателей)
Система управления базами данных (СУБД): PostgreSQL
Библиотека для работы с БД: libpqxx
## 2. Архитектура проекта
Проект разработан с использованием объектно-ориентированного подхода.
### Описание классов и их взаимосвязей
Основными сущностями системы являются классы User, Product, Order, DatabaseManager.
- User: Базовый класс для всех пользователей системы. Содержит общие атрибуты (ID, логин, роль).
- Admin, Manager, Customer: Классы-наследники от User, реализующие специфическую для роли логику и меню взаимодействия.
- Product: Представляет товар в каталоге.
Order: Представляет заказ, связывает покупателя с товарами и историей статусов.
- DatabaseManager: Синглтон-класс, управляющий всеми операциями с базой данных.
## Применение принципов ООП
В проекте активно используются ключевые принципы ООП:
- Наследование: Классы Admin, Manager, Customer наследуются от базового класса User, переопределяя поведение (например, доступное меню).
- Полиморфизм: Используется при работе с указателями или ссылками на базовый класс User для обработки различных типов пользователей единообразным способом.
- Композиция/Агрегация: Класс DatabaseManager использует (композирует) соединение с БД (pqxx::connection). Класс Order агрегирует список товаров (std::vector<Product>).
### Использование шаблонного класса DatabaseConnection<T>
Для обеспечения гибкости и возможности подключения к различным типам БД (если бы это потребовалось) используется шаблонный класс DatabaseConnection<T>. В данном проекте он инстанцируется с типом pqxx::connection, управляя жизненным циклом соединения с PostgreSQL и предоставляя общие методы для выполнения запросов.

## 3. Работа с базой данных
### Описание структуры базы данных
База данных построена по реляционной модели и нормализована. Используются внешние ключи для обеспечения целостности данных.
### Список таблиц
- users: Хранит данные о пользователях (id, username, password_hash, role).
- products: Каталог товаров (id, name, price, stock_quantity).
- orders: Основная информация о заказах (id, user_id, order_date, current_status).
- order_items: Детализация заказов (order_id, product_id, quantity, unit_price).
- order_status_history: Журнал изменения статусов заказов (id, order_id, status, change_date).
- audit_log: Общий журнал аудита действий пользователей (id, user_id, action_type, details, timestamp).
### Описание хранимых процедур, функций и триггеров
update_order_status_trigger: Триггер, который срабатывает при обновлении поля current_status в таблице orders и автоматически добавляет новую запись в таблицу order_status_history.
__log_user_action():__ Хранимая функция, вызываемая из бизнес-логики приложения для записи действий пользователей в audit_log.
### Механизм транзакций и отката при ошибках
Критические операции, такие как оформление заказа (списание средств, уменьшение остатков на складе, создание записей в нескольких таблицах), выполняются внутри транзакций libpqxx. Используется механизм __pqxx::work (или pqxx::transaction):__
- Если все операции в блоке try проходят успешно, вызывается __work.commit()__.
- В случае исключения (например, нехватки товара), транзакция автоматически откатывается (work.abort() вызывается деструктором work), гарантируя целостность данных.

## 4. Умные указатели и STL
В проекте активно используются современные возможности C++ для управления памятью и обработки данных.
### Где и почему используются std::unique_ptr и std::shared_ptr
- __std::unique_ptr:__ Используется для владения уникальными ресурсами. Например, при создании объекта User после входа в систему: __std::unique_ptr<User> currentUser(Authenticator::login(...))__. Это гарантирует автоматическое освобождение памяти при завершении сеанса пользователя.
- __std::shared_ptr:__ Используется реже, в сценариях, где несколько частей программы могут совместно владеть данными, например, при совместном доступе к объекту DatabaseManager из разных модулей (хотя в данном случае синглтон предпочтительнее).
Примеры использования STL
- __std::find_if__ и лямбда-выражения
Используется для поиска конкретного товара в векторе по его ID
- __std::copy_if__ и лямбда-выражения
Используется для фильтрации списка заказов, например, для выбора только активных заказов
- __std::accumulate__
Используется для расчета общей стоимости корзины или заказа

## 5. Логика ролей и прав доступа
Система реализует строгую модель контроля доступа (RBAC).
### Возможности администратора, менеджера и покупателя
| Роль | Возможности |
|:-----|:----------|
| Покупатель | Просмотр каталога, оформление заказов, просмотр своей истории заказов. |
| Менеджер | Все возможности покупателя, управление статусами всех заказов, просмотр каталога и управление запасами. |
| Администратор | Все возможности менеджера, управление пользователями (CRUD), просмотр полного журнала аудита, генерация отчетов. |
#### Ограничения доступа к истории заказов и журналу аудита
Покупатель может видеть только свои собственные заказы. Менеджер может видеть все заказы. Журнал аудита (audit_log) доступен только администратору.

## 6. Аудит и история изменений
Для обеспечения прозрачности и отслеживания изменений используются специальные таблицы журналирования.
#### Описание таблиц order_status_history и audit_log
- __order_status_history:__ Записывает каждое изменение статуса заказа с отметкой времени. Позволяет восстановить полный жизненный цикл заказа.
- __audit_log:__ Универсальный журнал для регистрации всех значимых действий пользователей (вход в систему, изменение данных товара, создание заказа, управление пользователями).
#### Механизм автоматического логирования
Логирование осуществляется двумя способами:
- Триггеры БД: Для __order_status_history__ используется триггер на уровне PostgreSQL , обеспечивающий автоматичность и надежность записи.
- Вызовы из C++ кода: При выполнении бизнес-логики, C++ код вызывает хранимую процедуру __log_user_action()__ для записи деталей действия.

## 7. Отчёт в формате CSV
#### Описание отчёта «История изменений заказов и действий пользователей»
Отчет объединяет данные из __order_status_history__ и __audit_log__ для предоставления полной картины активности в системе за определенный период. Формируется в формате CSV для удобства экспорта и анализа во внешних инструментах (например, Excel).

## 8. Сборка и запуск проекта
#### Требования к окружению
- Компилятор C++: GCC (G++) версии 9+ с поддержкой C++17.
- PostgreSQL Server: Установленный и запущенный сервер PostgreSQL.
- Библиотека libpqxx: Установленные заголовочные файлы и библиотеки.
- Инструмент сборки: CMake (версии 3.10+).
#### Инструкции по сборке:
Предполагается, что вы находитесь в корневом каталоге проекта (репозитория).

1. mkdir build
2. cd build
3. cmake ..
4. make

##### Или сборка в терминале
**Windows powershell:** __g++ -std=c++17 (Get-ChildItem src/*.cpp).FullName -lpqxx -lpq -o shop.exe__
**Linux Bash:** __g++ -std=c++17 src/*.cpp -lpqxx -lpq -o shop.exe__

#### Запуск: 
Запустите скомпилированное приложение из директории build.
./shop.exe

## 9. Примеры работы меню
#### ===== ИНТЕРНЕТ-МАГАЗИН =====
Пожалуйста, выберите свою роль:
1. Войти как Администратор
2. Войти как Менеджер
3. Войти как Покупатель
4. Выход

#### 1. === МЕНЮ АДМИНИСТРАТОРА ===
1. Добавить новый продукт
2. Обновить информацию о продукте
3. Удалить продукт
4. Просмотр всех заказов
5. Просмотр деталей заказа
6. Изменить статус заказа
7. Просмотр истории статусов заказа
8. Просмотр журнала аудита
9. Сформировать отчет (CSV)
10. Выход

#### 2. === МЕНЮ МЕНЕДЖЕРА ===
1. Просмотр заказов в ожидании утверждения
2. Утвердить заказ
3. Обновить количество товара на складе
4. Просмотр деталей заказа
5. Изменить статус заказа
6. Просмотр истории утвержденных заказов
7. Просмотр истории статусов заказов
8. Выход

#### 3. === МЕНЮ ПОКУПАТЕЛЯ ===
1. Создать новый заказ
2. Добавить товар в заказ
3. Удалить товар из заказа
4. Просмотр моих заказов
5. Просмотр статуса заказа
6. Оплатить заказ
7. Оформить возврат заказа
8. Просмотр истории статусов заказа
9. Выход