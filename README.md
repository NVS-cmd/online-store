# Создание системы интернет-магазина

## 1. Описание задачи
### Цель работы
Целью данной работы является разработка консольного приложения для управления интернет-магазином. Проект демонстрирует применение принципов объектно-ориентированного программирования (ООП), современных возможностей языка C++, работу с реляционной базой данных PostgreSQL и интеграцию с библиотекой libpqxx
### Краткое описание реализованной системы интернет-магазина
Реализованная система представляет собой консольное приложение с многопользовательским доступом, поддерживающее три основные роли: Администратор, Менеджер и Покупатель. Система позволяет пользователям просматривать каталог товаров, совершать покупки, управлять заказами, отслеживать историю статусов заказов и вести аудит действий. Администраторы имеют полный контроль над системой, включая управление пользователями и правами доступа.
### Используемые технологии
Язык программирования: C++ (современный стандарт, с использованием STL и умных указателей)
Система управления базами данных (СУБД): PostgreSQL
Библиотека для работы с БД: libpqxx
## 2. Архитектура проекта
Проект разработан с использованием объектно-ориентированного подхода.
### Описание классов и их взаимосвязей
Основными сущностями системы являются классы User, Product, Order, DatabaseManager.
- User: Базовый класс для всех пользователей системы. Содержит общие атрибуты (ID, логин, роль).
- Admin, Manager, Customer: Классы-наследники от User, реализующие специфическую для роли логику и меню взаимодействия.
- Product: Представляет товар в каталоге.
Order: Представляет заказ, связывает покупателя с товарами и историей статусов.
- DatabaseManager: Синглтон-класс, управляющий всеми операциями с базой данных.
## Применение принципов ООП
В проекте активно используются ключевые принципы ООП:
- Наследование: Классы Admin, Manager, Customer наследуются от базового класса User, переопределяя поведение (например, доступное меню).
- Полиморфизм: Используется при работе с указателями или ссылками на базовый класс User для обработки различных типов пользователей единообразным способом.
- Композиция/Агрегация: Класс DatabaseManager использует (композирует) соединение с БД (pqxx::connection). Класс Order агрегирует список товаров (std::vector<Product>).
### Использование шаблонного класса DatabaseConnection<T>
Для обеспечения гибкости и возможности подключения к различным типам БД (если бы это потребовалось) используется шаблонный класс DatabaseConnection<T>. В данном проекте он инстанцируется с типом pqxx::connection, управляя жизненным циклом соединения с PostgreSQL и предоставляя общие методы для выполнения запросов.

## 3. Работа с базой данных
### Описание структуры базы данных
База данных построена по реляционной модели и нормализована. Используются внешние ключи для обеспечения целостности данных.
### Список таблиц
- users: Хранит данные о пользователях (id, username, password_hash, role).
- products: Каталог товаров (id, name, price, stock_quantity).
- orders: Основная информация о заказах (id, user_id, order_date, current_status).
- order_items: Детализация заказов (order_id, product_id, quantity, unit_price).
- order_status_history: Журнал изменения статусов заказов (id, order_id, status, change_date).
- audit_log: Общий журнал аудита действий пользователей (id, user_id, action_type, details, timestamp).
### Описание хранимых процедур, функций и триггеров
update_order_status_trigger: Триггер, который срабатывает при обновлении поля current_status в таблице orders и автоматически добавляет новую запись в таблицу order_status_history.
log_user_action(): Хранимая функция, вызываемая из бизнес-логики приложения для записи действий пользователей в audit_log.
### Механизм транзакций и отката при ошибках
Критические операции, такие как оформление заказа (списание средств, уменьшение остатков на складе, создание записей в нескольких таблицах), выполняются внутри транзакций libpqxx. Используется механизм pqxx::work (или pqxx::transaction):
- Если все операции в блоке try проходят успешно, вызывается work.commit().
- В случае исключения (например, нехватки товара), транзакция автоматически откатывается (work.abort() вызывается деструктором work), гарантируя целостность данных.

## 4. Умные указатели и STL
В проекте активно используются современные возможности C++ для управления памятью и обработки данных.
### Где и почему используются std::unique_ptr и std::shared_ptr
- std::unique_ptr: Используется для владения уникальными ресурсами. Например, при создании объекта User после входа в систему: std::unique_ptr<User> currentUser(Authenticator::login(...)). Это гарантирует автоматическое освобождение памяти при завершении сеанса пользователя.
- std::shared_ptr: Используется реже, в сценариях, где несколько частей программы могут совместно владеть данными, например, при совместном доступе к объекту DatabaseManager из разных модулей (хотя в данном случае синглтон предпочтительнее).
Примеры использования STL
- std::find_if и лямбда-выражения
Используется для поиска конкретного товара в векторе по его ID
- std::copy_if и лямбда-выражения
Используется для фильтрации списка заказов, например, для выбора только активных заказов
- std::accumulate
Используется для расчета общей стоимости корзины или заказа

## 5. Логика ролей и прав доступа
Система реализует строгую модель контроля доступа (RBAC).
### Возможности администратора, менеджера и покупателя
|:Роль:|:Возможности:|
|:Покупатель:|:Просмотр каталога, оформление заказов, просмотр своей истории заказов.:|
|:Менеджер:|:Все возможности покупателя, управление статусами всех заказов, просмотр каталога и управление запасами.:|
|:Администратор:|:Все возможности менеджера, управление пользователями (CRUD), просмотр полного журнала аудита, генерация отчетов.:|
#### Ограничения доступа к истории заказов и журналу аудита
Покупатель может видеть только свои собственные заказы. Менеджер может видеть все заказы. Журнал аудита (audit_log) доступен только администратору.

## Сборка и запуск проекта